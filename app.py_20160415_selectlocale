from flask import Flask, render_template, request, redirect

import os
import psycopg2
import urlparse

import math
import numpy as np
from sklearn import linear_model as lm
from sklearn.metrics import r2_score
#import pandas as pd

from bokeh.plotting import *
from bokeh.embed import components
from bokeh.models import HoverTool,sources
from collections import OrderedDict

app = Flask(__name__)

demoIndex = [106, 172, 368, 449, 656]

# global variables to be used on different pages
app.vars={}
app.prices_actual=[]
app.prices_predicted=[]
app.features=[]
app.pctdiff=[]
app.scores=[]

@app.route('/')
def main():
  return redirect('/index')

@app.route('/index', methods=['POST', 'GET'])
def index():

  if request.method == 'POST':

    # get user-defined search area (currently not used)
    app.vars['qcenter'] =request.form['center']
    app.vars['qradius']= float(request.form['radius'].replace(' miles',''))
    #app.vars['qfeatures']=request.form['features']
    app.vars['qfeatures'] = request.form.getlist('features')
    feature_string =  getFeatureString(app.vars['qfeatures'])
    
    # get data from postgresql
    #urlparse.uses_netloc.append("postgres")
    #url = urlparse.urlparse(os.environ["DATABASE_URL"])
    try:
      conn = psycopg2.connect("dbname='nysRealEstate' user='enghuiy' host='localhost' password=''")
      #conn = psycopg2.connect(database=url.path[1:],user=url.username,password=url.password,host=url.hostname,port=url.port)
    except:
      return "Error: unable to connect to database"

    cur = conn.cursor()
    # 1) get long/lat base on zipcode
    cur.execute("""select lat,long from zipcode2longlat where zipcode=10583;""")
    zlat,zlong=cur.fetchone()

    # 2) get refshp_indices with (long/lat - centroid).dist < radius
    cur.execute("""SELECT refshpindex,centroid_lat,centroid_long FROM refshape;""")
    id_centroids=cur.fetchall()
    selectedids=[]
    for refshpindex,clat,clong in id_centroids: 
      d=distance_on_unit_sphere(clat, clong, zlat, zlong)
      if d <=app.vars['qradius']:
        selectedids.append(refshpindex)

    # 3) select price,features from lines matching these refshp_indices
    #    cur.execute("""SELECT refshape."NAME","ZPRICE","SCORE" from price2features JOIN refshape ON  price2features.=refshape."refSHPindex" WHERE "SCORE" > 0;""")
    queryString = generateQueryString(app.vars['qfeatures'],selectedids)
    print queryString
    cur.execute(queryString)
#    cur.execute("""SELECT refshape.name,zprice,sch_perform FROM price2features JOIN refshape ON price2features.refshpindex=refshape.refshpindex WHERE sch_perform > 0;""")


    
    data=zip(*cur.fetchall())
    refnames = list(data[0])
    homevalue = list(data[1])
    features  = list(data[2])
    #print "%10f %4.1f" %(homevalue[0],features[0]) 

    # 4) get the shapejsons from postgresql
    #try:
    #  cur.execute("""SELECT * from refshape where refshpindex=2;""")
    #except:
    #  print "cannot get jsons from database"
    #r = cur.fetchall()
    #geojsonFeature1=r[0][1]

    # run linear regression

    coeffs,intercept,r2,ypredicted =  linearRegression(features,homevalue)
    
    ypredicted_scaled = [ x / 1 for x in ypredicted]
    homevalue_scaled = [ x / 1 for x in homevalue]

    app.scores = [ 96.3, 21.2, -40.2, 60.1, 70.3, -55.4, 46.2, 33.6, -69.1,92.7]

    # plot with bokeh
    featureIndex=1
    #script, div = plotLR(features,homevalue_scaled,ypredicted_scaled,refnames,coeffs[featureIndex],intercept,r2)
    script, div = plotPrice2Price(features,homevalue_scaled,ypredicted_scaled,refnames,coeffs[featureIndex],intercept,r2)

    return render_template('graph.html', script=script, div=div, features=feature_string)
    #return render_template('temp.html',data=homevalue[0])

  return render_template('index.html')

@app.route('/map')
def map_test():

  try:
    conn = psycopg2.connect("dbname='nysRealEstate' user='enghuiy' host='localhost' password=''")
      #conn = psycopg2.connect(database=url.path[1:],user=url.username,password=url.password,host=url.hostname,port=url.port)
  except:
    return "Error: unable to connect to database"
  cur = conn.cursor()

  try:
    #cur.execute("""SELECT * from refshape where refshpindex=2;""")
    cur.execute("""SELECT json FROM refshape JOIN demoindices ON refshape.refshpindex=demoindices.refshpindex;""")
  except:
    print "cannot get jsons from database"

  r = cur.fetchall()
  geojsonFeatures = zip(*r)[0]
  temp=[] 
  #score_dum = [ 96.3, 21.2, -40.2, 60.1, 70.3, -55.4, 46.2, 33.6, -69.1,92.7]
  for i,jsonstring in enumerate(geojsonFeatures):
    t1=jsonstring.replace('"STATEFP": "36"','"score":%f' %app.scores[i])
    t2=t1.replace('{"type": "FeatureCollection", "features": [', '')
    t3=t2.replace('}}]}', '}}')
    temp.append(t3)
    
  geojsonFeatures_new='{"type": "FeatureCollection", "features": ['+','.join(temp)+']}'

  
  return render_template('map_test.html', gjson=geojsonFeatures_new)

#===================================================
 
def distance_on_unit_sphere(lat1, long1, lat2, long2):
 
    # Convert latitude and longitude to 
    # spherical coordinates in radians.
    degrees_to_radians = math.pi/180.0
         
    # phi = 90 - latitude
    phi1 = (90.0 - lat1)*degrees_to_radians
    phi2 = (90.0 - lat2)*degrees_to_radians
         
    # theta = longitude
    theta1 = long1*degrees_to_radians
    theta2 = long2*degrees_to_radians
         
    # Compute spherical distance from spherical coordinates.
    cos = (math.sin(phi1)*math.sin(phi2)*math.cos(theta1 - theta2) +
           math.cos(phi1)*math.cos(phi2))
    arc = math.acos( cos )
 
    # multiply arc by the radius of the earth in desired unit.
    return arc*3960 # miles
    #return arc*6373 # km

# normalization
def norm(x_in,x_norm):
    
    x_mu = np.mean(x_in)
    x_range = np.amax(x_in) - np.amin(x_in)
    x_norm [:] = [ ( x - x_mu ) / float (x_range) for x in x_in]
    return (x_mu, x_range)

# convert back to abs value
def unnorm(x_mu, x_range, x_norm):
    x_out=[]
    x_out [:] = [ x*x_range+x_mu for x in x_norm ]
    return x_out

# univariate regression
def linearRegression(features,homevalue):
    X_train = np.asarray(zip( np.ones(len(features)),features))

    # Create linear regression object
    regr = lm.LinearRegression()
    regr.fit(X_train, homevalue)
    coeffs = regr.coef_
    intercept = regr.intercept_

    # convert y back to abs value
    y_predicted_norm = regr.predict(X_train)
    y_predicted = regr.predict(X_train)

    r2=r2_score(homevalue, y_predicted)

    return (coeffs,intercept,r2,y_predicted)

def linearRegression_mynorm(features,homevalue):
    x_norm=[]; y_norm=[]
    (x_mu,x_range) = norm(features,x_norm)
    (y_mu, y_range) = norm(homevalue, y_norm)

    X_train = np.asarray(zip( np.ones(len(x_norm)),x_norm))

    # Create linear regression object
    regr = lm.LinearRegression()
    regr.fit(X_train, y_norm)
    coeffs = regr.coef_
    intercept = regr.intercept_

    # convert y back to abs value
    y_predicted_norm = regr.predict(X_train)
    y_predicted = unnorm(y_mu,y_range,y_predicted_norm)

    r2=r2_score(y_norm, y_predicted_norm)

    return (coeffs,intercept,r2,y_predicted)


# plot with bokeh
def mtext(p, x, y, text):
    p.text(x, y, text=[text],
           text_color="blue", text_font_style='bold',text_align="left", text_font_size="14pt")

def plotLR(feature1D,homevalue,y_predicted,refnames,coefficient,intercept,r2):

  TOOLS = 'box_zoom,box_select,resize,reset,hover'
  
  plot = figure(width=600, height=400,y_axis_label='Home Price ($)', x_axis_label='Features',tools=TOOLS)
  plot.line(feature1D,y_predicted,color='black',line_width=3)

  source = ColumnDataSource(
    data=dict(
      x=feature1D,
      y=homevalue,
      label=refnames
      )
    )

  plot.circle('x', 'y', color='blue',size=7, alpha=0.7, source=source)

  hover =plot.select(dict(type=HoverTool))
  hover.tooltips = OrderedDict([
    ("Locale", "@label"),
    ("(feature,price)", "(@x, @y)"),
    ])

  mtext(plot, min(feature1D) + 1,max(homevalue)-100000, "y = %6.2f x + (%6.2f)" %(coefficient,intercept))
  mtext(plot, min(feature1D) + 1,max(homevalue)-250000, "R2 = %5.3f" %(r2))

  script, div = components(plot)

  return (script, div)

def plotPrice2Price(feature1D,homevalue,y_predicted,refnames,coefficient,intercept,r2):

  TOOLS = 'box_zoom,box_select,resize,reset,hover'
  minap = min(y_predicted)
  maxap = max(y_predicted)

  plot = figure(width=600, height=450,y_axis_label='Actual Home Price ($)', x_axis_label='Expected Home Price ($)',tools=TOOLS)
  plot.line([minap,maxap],[minap,maxap],color='#525252',line_width=3)
  plot.xaxis.major_label_orientation = 3.142/4

  source = ColumnDataSource(
    data=dict(
      x=feature1D,
      y0=homevalue,
      y1=y_predicted,
      label=refnames
      )
    )

  plot.circle('y1', 'y0', color='blue',size=7, alpha=0.7, source=source)

  hover =plot.select(dict(type=HoverTool))
  hover.tooltips = OrderedDict([
    ("Locale", "@label"),
    ("Actual ($)", "@y0"),
    ("Expected ($)", "@y1"),
    ])

  mtext(plot, min(y_predicted) + 50000,max(homevalue)-100000, "y = %6.2f x + (%6.2f)" %(coefficient,intercept))
  mtext(plot, min(y_predicted) + 50000,max(homevalue)-250000, "R2 = %5.3f" %(r2))

  script, div = components(plot)

  return (script, div)

def getFeatureString(featurelist):
  outstring=''
  for i,f in enumerate(featurelist):
    if f=='school_performance':
      outstring += 'school performance'
    elif f=='crime_rate':
      outstring+='crime rate'
    elif f=='commute_time':
      outstring+='commute time'
    elif f=='walkability':
      outstring+='walkability'
    elif f=='roi':
      outstring+='ROI'
    else:
      pass
    if i<len(featurelist)-1:
      outstring+=', '
  return outstring

# try to generate the query

def generateQueryString(featurelist,refshpindexlist):
    featurestring=''
    for i,f in enumerate(featurelist):
        if f=='school_performance':
            featurestring += 'sch_perform'
        elif f=='crime_rate':
            featurestring+='crimerate_total'
        elif f=='commute_time':
            featurestring+='commute_time'
        elif f=='walkability':
            featurestring+='walkability'
        elif f=='roi':
            featurestring+='roi'
        else:
            pass
        if i<len(featurelist)-1:
            featurestring+=','
        
    criteriastring='refshape.refshpindex in ('+ ','.join([str(i) for i in refshpindexlist])+') and sch_perform > 0'

    outstring='SELECT refshape.name,zprice,'+ featurestring + ' from price2features JOIN refshape ON price2features.refshpindex=refshape.refshpindex WHERE '+ criteriastring 
        
    return outstring


# RUN
if __name__ == '__main__':
#  app.run(port=33507)
  app.run(debug=True,port=5001)
